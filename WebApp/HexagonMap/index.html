<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexagon test 6</title>
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.1/dist/svg.min.js"></script>
    
    <style>
        body {
            margin: 0px;
            padding: 0px;
        }
    </style>

</head>
<body>

    <script>

        var gap = 5;  // pixel gap between hexagons
        var margin = 10;

        var mouseOverHex = function() {
            this.fill({ color: '#f06' });
        }

        var mouseOutHex = function() {
            this.fill({ color: '#000' });
        }

        var clickOverHex = function() {
            this.fill({ color: '#f06' });
            this.animate(1,0).transform( { scale: 1.2 } );
            this.animate(300, 50).transform( { scale: 1 } );
            
        }

        var draw = SVG().addTo('body').size(1200, 1200);

        var hexCount = 10;
        var hexMaxColumnCount = 6;
        var hexContainer = [];

        var curHexCol = 0;
        var curHexRow = 0;   // The hexagons are added on this way: even row, odd row, even roww, odd row

        var hexHeight = 86.6;
        var hexWidth = 100;

        for (var n=0; n<hexCount; n++) {
            var newHex = draw.polygon('0,43.3 25,0 75,0 100,43.3 75,86.6 25,86.6');
            newHex.on('mouseover', mouseOverHex);
            newHex.on('click', clickOverHex);
            newHex.on('mouseout', mouseOutHex);

            // Update position counters
            console.log(`carFillRound: ${curHexRow} curHexCol: ${curHexCol} `);

            // Give position to the Hexagon
            var topPosition = 0;
            var leftPosition = 0;

            if ((curHexCol % 2) == 0 ) { // if column is even, the upper row
                topPosition = margin + curHexRow*(hexHeight+gap);
                leftPosition = margin + curHexCol*(0.75*hexWidth+gap);
                newHex.move(leftPosition, topPosition);
            } else { // odd col
                topPosition = margin + (hexHeight/2) + (gap/2) + (curHexRow)*(hexHeight+gap);
                leftPosition = margin + curHexCol*(0.75*hexWidth+gap);
                newHex.move(leftPosition, topPosition);
            }

            if ( curHexCol < hexMaxColumnCount-1 ) {
                curHexCol++;
            } else {
                curHexRow++;
                curHexCol = 0;
            }

            hexContainer = [...hexContainer, newHex];
        }

        console.log(hexContainer.length);
    </script>
    

</body>
</html>